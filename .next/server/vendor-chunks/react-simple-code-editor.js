"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-simple-code-editor";
exports.ids = ["vendor-chunks/react-simple-code-editor"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-simple-code-editor/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-simple-code-editor/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __assign = (void 0) && (void 0).__assign || function() {\n    __assign = Object.assign || function(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (void 0) && (void 0).__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __importStar(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows =  false && 0;\nvar isMacLike =  false && 0;\nvar className = \"npm__react-simple-code-editor__textarea\";\nvar cssText = /* CSS */ \"\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.\".concat(className, \":empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn't support '-webkit-text-fill-color'\\n    * So we use 'color: transparent' to make the text transparent on IE\\n    * Unlike other browsers, it doesn't affect caret color in IE\\n    */\\n  .\").concat(className, \" {\\n    color: transparent !important;\\n  }\\n\\n  .\").concat(className, \"::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n\");\nvar Editor = React.forwardRef(function Editor(props, ref) {\n    var autoFocus = props.autoFocus, disabled = props.disabled, form = props.form, highlight = props.highlight, _a = props.ignoreTabKey, ignoreTabKey = _a === void 0 ? false : _a, _b = props.insertSpaces, insertSpaces = _b === void 0 ? true : _b, maxLength = props.maxLength, minLength = props.minLength, name = props.name, onBlur = props.onBlur, onClick = props.onClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, onValueChange = props.onValueChange, _c = props.padding, padding = _c === void 0 ? 0 : _c, placeholder = props.placeholder, preClassName = props.preClassName, readOnly = props.readOnly, required = props.required, style = props.style, _d = props.tabSize, tabSize = _d === void 0 ? 2 : _d, textareaClassName = props.textareaClassName, textareaId = props.textareaId, value = props.value, rest = __rest(props, [\n        \"autoFocus\",\n        \"disabled\",\n        \"form\",\n        \"highlight\",\n        \"ignoreTabKey\",\n        \"insertSpaces\",\n        \"maxLength\",\n        \"minLength\",\n        \"name\",\n        \"onBlur\",\n        \"onClick\",\n        \"onFocus\",\n        \"onKeyDown\",\n        \"onKeyUp\",\n        \"onValueChange\",\n        \"padding\",\n        \"placeholder\",\n        \"preClassName\",\n        \"readOnly\",\n        \"required\",\n        \"style\",\n        \"tabSize\",\n        \"textareaClassName\",\n        \"textareaId\",\n        \"value\"\n    ]);\n    var historyRef = React.useRef({\n        stack: [],\n        offset: -1\n    });\n    var inputRef = React.useRef(null);\n    var _e = React.useState(true), capture = _e[0], setCapture = _e[1];\n    var contentStyle = {\n        paddingTop: typeof padding === \"object\" ? padding.top : padding,\n        paddingRight: typeof padding === \"object\" ? padding.right : padding,\n        paddingBottom: typeof padding === \"object\" ? padding.bottom : padding,\n        paddingLeft: typeof padding === \"object\" ? padding.left : padding\n    };\n    var highlighted = highlight(value);\n    var getLines = function(text, position) {\n        return text.substring(0, position).split(\"\\n\");\n    };\n    var recordChange = React.useCallback(function(record, overwrite) {\n        var _a, _b, _c;\n        if (overwrite === void 0) {\n            overwrite = false;\n        }\n        var _d = historyRef.current, stack = _d.stack, offset = _d.offset;\n        if (stack.length && offset > -1) {\n            // When something updates, drop the redo operations\n            historyRef.current.stack = stack.slice(0, offset + 1);\n            // Limit the number of operations to 100\n            var count = historyRef.current.stack.length;\n            if (count > HISTORY_LIMIT) {\n                var extras = count - HISTORY_LIMIT;\n                historyRef.current.stack = stack.slice(extras, count);\n                historyRef.current.offset = Math.max(historyRef.current.offset - extras, 0);\n            }\n        }\n        var timestamp = Date.now();\n        if (overwrite) {\n            var last = historyRef.current.stack[historyRef.current.offset];\n            if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n                // A previous entry exists and was in short interval\n                // Match the last word in the line\n                var re = /[^a-z0-9]([a-z0-9]+)$/i;\n                // Get the previous line\n                var previous = (_a = getLines(last.value, last.selectionStart).pop()) === null || _a === void 0 ? void 0 : _a.match(re);\n                // Get the current line\n                var current = (_b = getLines(record.value, record.selectionStart).pop()) === null || _b === void 0 ? void 0 : _b.match(re);\n                if ((previous === null || previous === void 0 ? void 0 : previous[1]) && ((_c = current === null || current === void 0 ? void 0 : current[1]) === null || _c === void 0 ? void 0 : _c.startsWith(previous[1]))) {\n                    // The last word of the previous line and current line match\n                    // Overwrite previous entry so that undo will remove whole word\n                    historyRef.current.stack[historyRef.current.offset] = __assign(__assign({}, record), {\n                        timestamp: timestamp\n                    });\n                    return;\n                }\n            }\n        }\n        // Add the new operation to the stack\n        historyRef.current.stack.push(__assign(__assign({}, record), {\n            timestamp: timestamp\n        }));\n        historyRef.current.offset++;\n    }, []);\n    var recordCurrentState = React.useCallback(function() {\n        var input = inputRef.current;\n        if (!input) return;\n        // Save current state of the input\n        var value = input.value, selectionStart = input.selectionStart, selectionEnd = input.selectionEnd;\n        recordChange({\n            value: value,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd\n        });\n    }, [\n        recordChange\n    ]);\n    var updateInput = function(record) {\n        var input = inputRef.current;\n        if (!input) return;\n        // Update values and selection state\n        input.value = record.value;\n        input.selectionStart = record.selectionStart;\n        input.selectionEnd = record.selectionEnd;\n        onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(record.value);\n    };\n    var applyEdits = function(record) {\n        // Save last selection state\n        var input = inputRef.current;\n        var last = historyRef.current.stack[historyRef.current.offset];\n        if (last && input) {\n            historyRef.current.stack[historyRef.current.offset] = __assign(__assign({}, last), {\n                selectionStart: input.selectionStart,\n                selectionEnd: input.selectionEnd\n            });\n        }\n        // Save the changes\n        recordChange(record);\n        updateInput(record);\n    };\n    var undoEdit = function() {\n        var _a = historyRef.current, stack = _a.stack, offset = _a.offset;\n        // Get the previous edit\n        var record = stack[offset - 1];\n        if (record) {\n            // Apply the changes and update the offset\n            updateInput(record);\n            historyRef.current.offset = Math.max(offset - 1, 0);\n        }\n    };\n    var redoEdit = function() {\n        var _a = historyRef.current, stack = _a.stack, offset = _a.offset;\n        // Get the next edit\n        var record = stack[offset + 1];\n        if (record) {\n            // Apply the changes and update the offset\n            updateInput(record);\n            historyRef.current.offset = Math.min(offset + 1, stack.length - 1);\n        }\n    };\n    var handleKeyDown = function(e) {\n        if (onKeyDown) {\n            onKeyDown(e);\n            if (e.defaultPrevented) {\n                return;\n            }\n        }\n        if (e.key === \"Escape\") {\n            e.currentTarget.blur();\n        }\n        var _a = e.currentTarget, value = _a.value, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n        var tabCharacter = (insertSpaces ? \" \" : \"\t\").repeat(tabSize);\n        if (e.key === \"Tab\" && !ignoreTabKey && capture) {\n            // Prevent focus change\n            e.preventDefault();\n            if (e.shiftKey) {\n                // Unindent selected lines\n                var linesBeforeCaret = getLines(value, selectionStart);\n                var startLine_1 = linesBeforeCaret.length - 1;\n                var endLine_1 = getLines(value, selectionEnd).length - 1;\n                var nextValue = value.split(\"\\n\").map(function(line, i) {\n                    if (i >= startLine_1 && i <= endLine_1 && line.startsWith(tabCharacter)) {\n                        return line.substring(tabCharacter.length);\n                    }\n                    return line;\n                }).join(\"\\n\");\n                if (value !== nextValue) {\n                    var startLineText = linesBeforeCaret[startLine_1];\n                    applyEdits({\n                        value: nextValue,\n                        // Move the start cursor if first line in selection was modified\n                        // It was modified only if it started with a tab\n                        selectionStart: (startLineText === null || startLineText === void 0 ? void 0 : startLineText.startsWith(tabCharacter)) ? selectionStart - tabCharacter.length : selectionStart,\n                        // Move the end cursor by total number of characters removed\n                        selectionEnd: selectionEnd - (value.length - nextValue.length)\n                    });\n                }\n            } else if (selectionStart !== selectionEnd) {\n                // Indent selected lines\n                var linesBeforeCaret = getLines(value, selectionStart);\n                var startLine_2 = linesBeforeCaret.length - 1;\n                var endLine_2 = getLines(value, selectionEnd).length - 1;\n                var startLineText = linesBeforeCaret[startLine_2];\n                applyEdits({\n                    value: value.split(\"\\n\").map(function(line, i) {\n                        if (i >= startLine_2 && i <= endLine_2) {\n                            return tabCharacter + line;\n                        }\n                        return line;\n                    }).join(\"\\n\"),\n                    // Move the start cursor by number of characters added in first line of selection\n                    // Don't move it if it there was no text before cursor\n                    selectionStart: startLineText && /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n                    // Move the end cursor by total number of characters added\n                    selectionEnd: selectionEnd + tabCharacter.length * (endLine_2 - startLine_2 + 1)\n                });\n            } else {\n                var updatedSelection = selectionStart + tabCharacter.length;\n                applyEdits({\n                    // Insert tab character at caret\n                    value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n                    // Update caret position\n                    selectionStart: updatedSelection,\n                    selectionEnd: updatedSelection\n                });\n            }\n        } else if (e.key === \"Backspace\") {\n            var hasSelection = selectionStart !== selectionEnd;\n            var textBeforeCaret = value.substring(0, selectionStart);\n            if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n                // Prevent default delete behaviour\n                e.preventDefault();\n                var updatedSelection = selectionStart - tabCharacter.length;\n                applyEdits({\n                    // Remove tab character at caret\n                    value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n                    // Update caret position\n                    selectionStart: updatedSelection,\n                    selectionEnd: updatedSelection\n                });\n            }\n        } else if (e.key === \"Enter\") {\n            // Ignore selections\n            if (selectionStart === selectionEnd) {\n                // Get the current line\n                var line = getLines(value, selectionStart).pop();\n                var matches = line === null || line === void 0 ? void 0 : line.match(/^\\s+/);\n                if (matches === null || matches === void 0 ? void 0 : matches[0]) {\n                    e.preventDefault();\n                    // Preserve indentation on inserting a new line\n                    var indent = \"\\n\" + matches[0];\n                    var updatedSelection = selectionStart + indent.length;\n                    applyEdits({\n                        // Insert indentation character at caret\n                        value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n                        // Update caret position\n                        selectionStart: updatedSelection,\n                        selectionEnd: updatedSelection\n                    });\n                }\n            }\n        } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n            var chars = void 0;\n            if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n                chars = [\n                    \"(\",\n                    \")\"\n                ];\n            } else if (e.keyCode === KEYCODE_BRACKETS) {\n                if (e.shiftKey) {\n                    chars = [\n                        \"{\",\n                        \"}\"\n                    ];\n                } else {\n                    chars = [\n                        \"[\",\n                        \"]\"\n                    ];\n                }\n            } else if (e.keyCode === KEYCODE_QUOTE) {\n                if (e.shiftKey) {\n                    chars = [\n                        '\"',\n                        '\"'\n                    ];\n                } else {\n                    chars = [\n                        \"'\",\n                        \"'\"\n                    ];\n                }\n            } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n                chars = [\n                    \"`\",\n                    \"`\"\n                ];\n            }\n            // If text is selected, wrap them in the characters\n            if (selectionStart !== selectionEnd && chars) {\n                e.preventDefault();\n                applyEdits({\n                    value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n                    // Update caret position\n                    selectionStart: selectionStart,\n                    selectionEnd: selectionEnd + 2\n                });\n            }\n        } else if ((isMacLike ? e.metaKey && e.keyCode === KEYCODE_Z : e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n            e.preventDefault();\n            undoEdit();\n        } else if ((isMacLike ? e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ? e.ctrlKey && e.keyCode === KEYCODE_Y : e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n            e.preventDefault();\n            redoEdit();\n        } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n            e.preventDefault();\n            // Toggle capturing tab key so users can focus away\n            setCapture(function(prev) {\n                return !prev;\n            });\n        }\n    };\n    var handleChange = function(e) {\n        var _a = e.currentTarget, value = _a.value, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n        recordChange({\n            value: value,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd\n        }, true);\n        onValueChange(value);\n    };\n    React.useEffect(function() {\n        recordCurrentState();\n    }, [\n        recordCurrentState\n    ]);\n    React.useImperativeHandle(ref, function() {\n        return {\n            get session () {\n                return {\n                    history: historyRef.current\n                };\n            },\n            set session (session){\n                historyRef.current = session.history;\n            }\n        };\n    }, []);\n    return React.createElement(\"div\", __assign({}, rest, {\n        style: __assign(__assign({}, styles.container), style)\n    }), React.createElement(\"pre\", __assign({\n        className: preClassName,\n        \"aria-hidden\": \"true\",\n        style: __assign(__assign(__assign({}, styles.editor), styles.highlight), contentStyle)\n    }, typeof highlighted === \"string\" ? {\n        dangerouslySetInnerHTML: {\n            __html: highlighted + \"<br />\"\n        }\n    } : {\n        children: highlighted\n    })), React.createElement(\"textarea\", {\n        ref: function(c) {\n            return inputRef.current = c;\n        },\n        style: __assign(__assign(__assign({}, styles.editor), styles.textarea), contentStyle),\n        className: className + (textareaClassName ? \" \".concat(textareaClassName) : \"\"),\n        id: textareaId,\n        value: value,\n        onChange: handleChange,\n        onKeyDown: handleKeyDown,\n        onClick: onClick,\n        onKeyUp: onKeyUp,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        disabled: disabled,\n        form: form,\n        maxLength: maxLength,\n        minLength: minLength,\n        name: name,\n        placeholder: placeholder,\n        readOnly: readOnly,\n        required: required,\n        autoFocus: autoFocus,\n        autoCapitalize: \"off\",\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        spellCheck: false,\n        \"data-gramm\": false\n    }), React.createElement(\"style\", {\n        dangerouslySetInnerHTML: {\n            __html: cssText\n        }\n    }));\n});\nvar styles = {\n    container: {\n        position: \"relative\",\n        textAlign: \"left\",\n        boxSizing: \"border-box\",\n        padding: 0,\n        overflow: \"hidden\"\n    },\n    textarea: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        height: \"100%\",\n        width: \"100%\",\n        resize: \"none\",\n        color: \"inherit\",\n        overflow: \"hidden\",\n        MozOsxFontSmoothing: \"grayscale\",\n        WebkitFontSmoothing: \"antialiased\",\n        WebkitTextFillColor: \"transparent\"\n    },\n    highlight: {\n        position: \"relative\",\n        pointerEvents: \"none\"\n    },\n    editor: {\n        margin: 0,\n        border: 0,\n        background: \"none\",\n        boxSizing: \"inherit\",\n        display: \"inherit\",\n        fontFamily: \"inherit\",\n        fontSize: \"inherit\",\n        fontStyle: \"inherit\",\n        fontVariantLigatures: \"inherit\",\n        fontWeight: \"inherit\",\n        letterSpacing: \"inherit\",\n        lineHeight: \"inherit\",\n        tabSize: \"inherit\",\n        textIndent: \"inherit\",\n        textRendering: \"inherit\",\n        textTransform: \"inherit\",\n        whiteSpace: \"pre-wrap\",\n        wordBreak: \"keep-all\",\n        overflowWrap: \"break-word\"\n    }\n};\nexports[\"default\"] = Editor; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLWNvZGUtZWRpdG9yL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFdBQVcsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxRQUFRLElBQUs7SUFDdENBLFdBQVdDLE9BQU9DLE1BQU0sSUFBSSxTQUFTQyxDQUFDO1FBQ2xDLElBQUssSUFBSUMsR0FBR0MsSUFBSSxHQUFHQyxJQUFJQyxVQUFVQyxNQUFNLEVBQUVILElBQUlDLEdBQUdELElBQUs7WUFDakRELElBQUlHLFNBQVMsQ0FBQ0YsRUFBRTtZQUNoQixJQUFLLElBQUlJLEtBQUtMLEVBQUcsSUFBSUgsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFDekROLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7UUFDbkI7UUFDQSxPQUFPTjtJQUNYO0lBQ0EsT0FBT0gsU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRU47QUFDaEM7QUFDQSxJQUFJTyxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1iLENBQUFBLE9BQU9jLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9wQixPQUFPcUIsd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQWpCLE9BQU8yQixjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0ws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O1FBQ1Y2RixlQUFlO0lBQ25CO0lBQ0F0QixRQUFRO1FBQ0p1QixRQUFRO1FBQ1JDLFFBQVE7UUFDUkMsWUFBWTtRQUNaWixXQUFXO1FBQ1hhLFNBQVM7UUFDVEMsWUFBWTtRQUNaQyxVQUFVO1FBQ1ZDLFdBQVc7UUFDWEMsc0JBQXNCO1FBQ3RCQyxZQUFZO1FBQ1pDLGVBQWU7UUFDZkMsWUFBWTtRQUNaakksU0FBUztRQUNUa0ksWUFBWTtRQUNaQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsWUFBWTtRQUNaQyxXQUFXO1FBQ1hDLGNBQWM7SUFDbEI7QUFDSjtBQUNBekwsa0JBQWUsR0FBR3FCLFFBQ2xCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JleGkteGlhb2hvbmdzaHUtZ2VuLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNpbXBsZS1jb2RlLWVkaXRvci9saWIvaW5kZXguanM/YmY0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEtFWUNPREVfWSA9IDg5O1xudmFyIEtFWUNPREVfWiA9IDkwO1xudmFyIEtFWUNPREVfTSA9IDc3O1xudmFyIEtFWUNPREVfUEFSRU5TID0gNTc7XG52YXIgS0VZQ09ERV9CUkFDS0VUUyA9IDIxOTtcbnZhciBLRVlDT0RFX1FVT1RFID0gMjIyO1xudmFyIEtFWUNPREVfQkFDS19RVU9URSA9IDE5MjtcbnZhciBISVNUT1JZX0xJTUlUID0gMTAwO1xudmFyIEhJU1RPUllfVElNRV9HQVAgPSAzMDAwO1xudmFyIGlzV2luZG93cyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ25hdmlnYXRvcicgaW4gd2luZG93ICYmXG4gICAgL1dpbi9pLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciBpc01hY0xpa2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICduYXZpZ2F0b3InIGluIHdpbmRvdyAmJlxuICAgIC8oTWFjfGlQaG9uZXxpUG9kfGlQYWQpL2kudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xudmFyIGNsYXNzTmFtZSA9ICducG1fX3JlYWN0LXNpbXBsZS1jb2RlLWVkaXRvcl9fdGV4dGFyZWEnO1xudmFyIGNzc1RleHQgPSAvKiBDU1MgKi8gXCJcXG4vKipcXG4gKiBSZXNldCB0aGUgdGV4dCBmaWxsIGNvbG9yIHNvIHRoYXQgcGxhY2Vob2xkZXIgaXMgdmlzaWJsZVxcbiAqL1xcbi5cIi5jb25jYXQoY2xhc3NOYW1lLCBcIjplbXB0eSB7XFxuICAtd2Via2l0LXRleHQtZmlsbC1jb2xvcjogaW5oZXJpdCAhaW1wb3J0YW50O1xcbn1cXG5cXG4vKipcXG4gKiBIYWNrIHRvIGFwcGx5IG9uIHNvbWUgQ1NTIG9uIElFMTAgYW5kIElFMTFcXG4gKi9cXG5AbWVkaWEgYWxsIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6IG5vbmUpLCAoLW1zLWhpZ2gtY29udHJhc3Q6IGFjdGl2ZSkge1xcbiAgLyoqXFxuICAgICogSUUgZG9lc24ndCBzdXBwb3J0ICctd2Via2l0LXRleHQtZmlsbC1jb2xvcidcXG4gICAgKiBTbyB3ZSB1c2UgJ2NvbG9yOiB0cmFuc3BhcmVudCcgdG8gbWFrZSB0aGUgdGV4dCB0cmFuc3BhcmVudCBvbiBJRVxcbiAgICAqIFVubGlrZSBvdGhlciBicm93c2VycywgaXQgZG9lc24ndCBhZmZlY3QgY2FyZXQgY29sb3IgaW4gSUVcXG4gICAgKi9cXG4gIC5cIikuY29uY2F0KGNsYXNzTmFtZSwgXCIge1xcbiAgICBjb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXG4gIH1cXG5cXG4gIC5cIikuY29uY2F0KGNsYXNzTmFtZSwgXCI6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNhY2NlZjcgIWltcG9ydGFudDtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XFxuICB9XFxufVxcblwiKTtcbnZhciBFZGl0b3IgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEVkaXRvcihwcm9wcywgcmVmKSB7XG4gICAgdmFyIGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cywgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCwgZm9ybSA9IHByb3BzLmZvcm0sIGhpZ2hsaWdodCA9IHByb3BzLmhpZ2hsaWdodCwgX2EgPSBwcm9wcy5pZ25vcmVUYWJLZXksIGlnbm9yZVRhYktleSA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IHByb3BzLmluc2VydFNwYWNlcywgaW5zZXJ0U3BhY2VzID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgbWF4TGVuZ3RoID0gcHJvcHMubWF4TGVuZ3RoLCBtaW5MZW5ndGggPSBwcm9wcy5taW5MZW5ndGgsIG5hbWUgPSBwcm9wcy5uYW1lLCBvbkJsdXIgPSBwcm9wcy5vbkJsdXIsIG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrLCBvbkZvY3VzID0gcHJvcHMub25Gb2N1cywgb25LZXlEb3duID0gcHJvcHMub25LZXlEb3duLCBvbktleVVwID0gcHJvcHMub25LZXlVcCwgb25WYWx1ZUNoYW5nZSA9IHByb3BzLm9uVmFsdWVDaGFuZ2UsIF9jID0gcHJvcHMucGFkZGluZywgcGFkZGluZyA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIHBsYWNlaG9sZGVyID0gcHJvcHMucGxhY2Vob2xkZXIsIHByZUNsYXNzTmFtZSA9IHByb3BzLnByZUNsYXNzTmFtZSwgcmVhZE9ubHkgPSBwcm9wcy5yZWFkT25seSwgcmVxdWlyZWQgPSBwcm9wcy5yZXF1aXJlZCwgc3R5bGUgPSBwcm9wcy5zdHlsZSwgX2QgPSBwcm9wcy50YWJTaXplLCB0YWJTaXplID0gX2QgPT09IHZvaWQgMCA/IDIgOiBfZCwgdGV4dGFyZWFDbGFzc05hbWUgPSBwcm9wcy50ZXh0YXJlYUNsYXNzTmFtZSwgdGV4dGFyZWFJZCA9IHByb3BzLnRleHRhcmVhSWQsIHZhbHVlID0gcHJvcHMudmFsdWUsIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcImF1dG9Gb2N1c1wiLCBcImRpc2FibGVkXCIsIFwiZm9ybVwiLCBcImhpZ2hsaWdodFwiLCBcImlnbm9yZVRhYktleVwiLCBcImluc2VydFNwYWNlc1wiLCBcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiLCBcIm5hbWVcIiwgXCJvbkJsdXJcIiwgXCJvbkNsaWNrXCIsIFwib25Gb2N1c1wiLCBcIm9uS2V5RG93blwiLCBcIm9uS2V5VXBcIiwgXCJvblZhbHVlQ2hhbmdlXCIsIFwicGFkZGluZ1wiLCBcInBsYWNlaG9sZGVyXCIsIFwicHJlQ2xhc3NOYW1lXCIsIFwicmVhZE9ubHlcIiwgXCJyZXF1aXJlZFwiLCBcInN0eWxlXCIsIFwidGFiU2l6ZVwiLCBcInRleHRhcmVhQ2xhc3NOYW1lXCIsIFwidGV4dGFyZWFJZFwiLCBcInZhbHVlXCJdKTtcbiAgICB2YXIgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZih7XG4gICAgICAgIHN0YWNrOiBbXSxcbiAgICAgICAgb2Zmc2V0OiAtMSxcbiAgICB9KTtcbiAgICB2YXIgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIF9lID0gUmVhY3QudXNlU3RhdGUodHJ1ZSksIGNhcHR1cmUgPSBfZVswXSwgc2V0Q2FwdHVyZSA9IF9lWzFdO1xuICAgIHZhciBjb250ZW50U3R5bGUgPSB7XG4gICAgICAgIHBhZGRpbmdUb3A6IHR5cGVvZiBwYWRkaW5nID09PSAnb2JqZWN0JyA/IHBhZGRpbmcudG9wIDogcGFkZGluZyxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiB0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcgPyBwYWRkaW5nLnJpZ2h0IDogcGFkZGluZyxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogdHlwZW9mIHBhZGRpbmcgPT09ICdvYmplY3QnID8gcGFkZGluZy5ib3R0b20gOiBwYWRkaW5nLFxuICAgICAgICBwYWRkaW5nTGVmdDogdHlwZW9mIHBhZGRpbmcgPT09ICdvYmplY3QnID8gcGFkZGluZy5sZWZ0IDogcGFkZGluZyxcbiAgICB9O1xuICAgIHZhciBoaWdobGlnaHRlZCA9IGhpZ2hsaWdodCh2YWx1ZSk7XG4gICAgdmFyIGdldExpbmVzID0gZnVuY3Rpb24gKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZygwLCBwb3NpdGlvbikuc3BsaXQoJ1xcbicpO1xuICAgIH07XG4gICAgdmFyIHJlY29yZENoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyZWNvcmQsIG92ZXJ3cml0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSA9PT0gdm9pZCAwKSB7IG92ZXJ3cml0ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfZCA9IGhpc3RvcnlSZWYuY3VycmVudCwgc3RhY2sgPSBfZC5zdGFjaywgb2Zmc2V0ID0gX2Qub2Zmc2V0O1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoICYmIG9mZnNldCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHNvbWV0aGluZyB1cGRhdGVzLCBkcm9wIHRoZSByZWRvIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIGhpc3RvcnlSZWYuY3VycmVudC5zdGFjayA9IHN0YWNrLnNsaWNlKDAsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgLy8gTGltaXQgdGhlIG51bWJlciBvZiBvcGVyYXRpb25zIHRvIDEwMFxuICAgICAgICAgICAgdmFyIGNvdW50ID0gaGlzdG9yeVJlZi5jdXJyZW50LnN0YWNrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IEhJU1RPUllfTElNSVQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFzID0gY291bnQgLSBISVNUT1JZX0xJTUlUO1xuICAgICAgICAgICAgICAgIGhpc3RvcnlSZWYuY3VycmVudC5zdGFjayA9IHN0YWNrLnNsaWNlKGV4dHJhcywgY291bnQpO1xuICAgICAgICAgICAgICAgIGhpc3RvcnlSZWYuY3VycmVudC5vZmZzZXQgPSBNYXRoLm1heChoaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0IC0gZXh0cmFzLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBoaXN0b3J5UmVmLmN1cnJlbnQuc3RhY2tbaGlzdG9yeVJlZi5jdXJyZW50Lm9mZnNldF07XG4gICAgICAgICAgICBpZiAobGFzdCAmJiB0aW1lc3RhbXAgLSBsYXN0LnRpbWVzdGFtcCA8IEhJU1RPUllfVElNRV9HQVApIHtcbiAgICAgICAgICAgICAgICAvLyBBIHByZXZpb3VzIGVudHJ5IGV4aXN0cyBhbmQgd2FzIGluIHNob3J0IGludGVydmFsXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggdGhlIGxhc3Qgd29yZCBpbiB0aGUgbGluZVxuICAgICAgICAgICAgICAgIHZhciByZSA9IC9bXmEtejAtOV0oW2EtejAtOV0rKSQvaTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHByZXZpb3VzIGxpbmVcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSAoX2EgPSBnZXRMaW5lcyhsYXN0LnZhbHVlLCBsYXN0LnNlbGVjdGlvblN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAucG9wKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXRjaChyZSk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IChfYiA9IGdldExpbmVzKHJlY29yZC52YWx1ZSwgcmVjb3JkLnNlbGVjdGlvblN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAucG9wKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXRjaChyZSk7XG4gICAgICAgICAgICAgICAgaWYgKChwcmV2aW91cyA9PT0gbnVsbCB8fCBwcmV2aW91cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXNbMV0pICYmICgoX2MgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRbMV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdGFydHNXaXRoKHByZXZpb3VzWzFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxhc3Qgd29yZCBvZiB0aGUgcHJldmlvdXMgbGluZSBhbmQgY3VycmVudCBsaW5lIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSBwcmV2aW91cyBlbnRyeSBzbyB0aGF0IHVuZG8gd2lsbCByZW1vdmUgd2hvbGUgd29yZFxuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5UmVmLmN1cnJlbnQuc3RhY2tbaGlzdG9yeVJlZi5jdXJyZW50Lm9mZnNldF0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVjb3JkKSwgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBvcGVyYXRpb24gdG8gdGhlIHN0YWNrXG4gICAgICAgIGhpc3RvcnlSZWYuY3VycmVudC5zdGFjay5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWNvcmQpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wIH0pKTtcbiAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50Lm9mZnNldCsrO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgcmVjb3JkQ3VycmVudFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTYXZlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGlucHV0XG4gICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlLCBzZWxlY3Rpb25TdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgPSBpbnB1dC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIHJlY29yZENoYW5nZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCxcbiAgICAgICAgfSk7XG4gICAgfSwgW3JlY29yZENoYW5nZV0pO1xuICAgIHZhciB1cGRhdGVJbnB1dCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVXBkYXRlIHZhbHVlcyBhbmQgc2VsZWN0aW9uIHN0YXRlXG4gICAgICAgIGlucHV0LnZhbHVlID0gcmVjb3JkLnZhbHVlO1xuICAgICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHJlY29yZC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gcmVjb3JkLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgb25WYWx1ZUNoYW5nZSA9PT0gbnVsbCB8fCBvblZhbHVlQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblZhbHVlQ2hhbmdlKHJlY29yZC52YWx1ZSk7XG4gICAgfTtcbiAgICB2YXIgYXBwbHlFZGl0cyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgLy8gU2F2ZSBsYXN0IHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgbGFzdCA9IGhpc3RvcnlSZWYuY3VycmVudC5zdGFja1toaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0XTtcbiAgICAgICAgaWYgKGxhc3QgJiYgaW5wdXQpIHtcbiAgICAgICAgICAgIGhpc3RvcnlSZWYuY3VycmVudC5zdGFja1toaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0XSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsYXN0KSwgeyBzZWxlY3Rpb25TdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZDogaW5wdXQuc2VsZWN0aW9uRW5kIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNhdmUgdGhlIGNoYW5nZXNcbiAgICAgICAgcmVjb3JkQ2hhbmdlKHJlY29yZCk7XG4gICAgICAgIHVwZGF0ZUlucHV0KHJlY29yZCk7XG4gICAgfTtcbiAgICB2YXIgdW5kb0VkaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IGhpc3RvcnlSZWYuY3VycmVudCwgc3RhY2sgPSBfYS5zdGFjaywgb2Zmc2V0ID0gX2Eub2Zmc2V0O1xuICAgICAgICAvLyBHZXQgdGhlIHByZXZpb3VzIGVkaXRcbiAgICAgICAgdmFyIHJlY29yZCA9IHN0YWNrW29mZnNldCAtIDFdO1xuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgY2hhbmdlcyBhbmQgdXBkYXRlIHRoZSBvZmZzZXRcbiAgICAgICAgICAgIHVwZGF0ZUlucHV0KHJlY29yZCk7XG4gICAgICAgICAgICBoaXN0b3J5UmVmLmN1cnJlbnQub2Zmc2V0ID0gTWF0aC5tYXgob2Zmc2V0IC0gMSwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWRvRWRpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gaGlzdG9yeVJlZi5jdXJyZW50LCBzdGFjayA9IF9hLnN0YWNrLCBvZmZzZXQgPSBfYS5vZmZzZXQ7XG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBlZGl0XG4gICAgICAgIHZhciByZWNvcmQgPSBzdGFja1tvZmZzZXQgKyAxXTtcbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGNoYW5nZXMgYW5kIHVwZGF0ZSB0aGUgb2Zmc2V0XG4gICAgICAgICAgICB1cGRhdGVJbnB1dChyZWNvcmQpO1xuICAgICAgICAgICAgaGlzdG9yeVJlZi5jdXJyZW50Lm9mZnNldCA9IE1hdGgubWluKG9mZnNldCArIDEsIHN0YWNrLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChvbktleURvd24pIHtcbiAgICAgICAgICAgIG9uS2V5RG93bihlKTtcbiAgICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBlLmN1cnJlbnRUYXJnZXQsIHZhbHVlID0gX2EudmFsdWUsIHNlbGVjdGlvblN0YXJ0ID0gX2Euc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCA9IF9hLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgdmFyIHRhYkNoYXJhY3RlciA9IChpbnNlcnRTcGFjZXMgPyAnICcgOiAnXFx0JykucmVwZWF0KHRhYlNpemUpO1xuICAgICAgICBpZiAoZS5rZXkgPT09ICdUYWInICYmICFpZ25vcmVUYWJLZXkgJiYgY2FwdHVyZSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBmb2N1cyBjaGFuZ2VcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVW5pbmRlbnQgc2VsZWN0ZWQgbGluZXNcbiAgICAgICAgICAgICAgICB2YXIgbGluZXNCZWZvcmVDYXJldCA9IGdldExpbmVzKHZhbHVlLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZV8xID0gbGluZXNCZWZvcmVDYXJldC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBlbmRMaW5lXzEgPSBnZXRMaW5lcyh2YWx1ZSwgc2VsZWN0aW9uRW5kKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gc3RhcnRMaW5lXzEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPD0gZW5kTGluZV8xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLnN0YXJ0c1dpdGgodGFiQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUuc3Vic3RyaW5nKHRhYkNoYXJhY3Rlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lVGV4dCA9IGxpbmVzQmVmb3JlQ2FyZXRbc3RhcnRMaW5lXzFdO1xuICAgICAgICAgICAgICAgICAgICBhcHBseUVkaXRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXh0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBzdGFydCBjdXJzb3IgaWYgZmlyc3QgbGluZSBpbiBzZWxlY3Rpb24gd2FzIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCB3YXMgbW9kaWZpZWQgb25seSBpZiBpdCBzdGFydGVkIHdpdGggYSB0YWJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiAoc3RhcnRMaW5lVGV4dCA9PT0gbnVsbCB8fCBzdGFydExpbmVUZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFydExpbmVUZXh0LnN0YXJ0c1dpdGgodGFiQ2hhcmFjdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdGlvblN0YXJ0IC0gdGFiQ2hhcmFjdGVyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBlbmQgY3Vyc29yIGJ5IHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogc2VsZWN0aW9uRW5kIC0gKHZhbHVlLmxlbmd0aCAtIG5leHRWYWx1ZS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5kZW50IHNlbGVjdGVkIGxpbmVzXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzQmVmb3JlQ2FyZXQgPSBnZXRMaW5lcyh2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmVfMiA9IGxpbmVzQmVmb3JlQ2FyZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kTGluZV8yID0gZ2V0TGluZXModmFsdWUsIHNlbGVjdGlvbkVuZCkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lVGV4dCA9IGxpbmVzQmVmb3JlQ2FyZXRbc3RhcnRMaW5lXzJdO1xuICAgICAgICAgICAgICAgIGFwcGx5RWRpdHMoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID49IHN0YXJ0TGluZV8yICYmIGkgPD0gZW5kTGluZV8yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYkNoYXJhY3RlciArIGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgc3RhcnQgY3Vyc29yIGJ5IG51bWJlciBvZiBjaGFyYWN0ZXJzIGFkZGVkIGluIGZpcnN0IGxpbmUgb2Ygc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IG1vdmUgaXQgaWYgaXQgdGhlcmUgd2FzIG5vIHRleHQgYmVmb3JlIGN1cnNvclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc3RhcnRMaW5lVGV4dCAmJiAvXFxTLy50ZXN0KHN0YXJ0TGluZVRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdGlvblN0YXJ0ICsgdGFiQ2hhcmFjdGVyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgZW5kIGN1cnNvciBieSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBhZGRlZFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCArIHRhYkNoYXJhY3Rlci5sZW5ndGggKiAoZW5kTGluZV8yIC0gc3RhcnRMaW5lXzIgKyAxKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkU2VsZWN0aW9uID0gc2VsZWN0aW9uU3RhcnQgKyB0YWJDaGFyYWN0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGFwcGx5RWRpdHMoe1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGFiIGNoYXJhY3RlciBhdCBjYXJldFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJDaGFyYWN0ZXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogdXBkYXRlZFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiB1cGRhdGVkU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgdmFyIGhhc1NlbGVjdGlvbiA9IHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB2YXIgdGV4dEJlZm9yZUNhcmV0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0ZXh0QmVmb3JlQ2FyZXQuZW5kc1dpdGgodGFiQ2hhcmFjdGVyKSAmJiAhaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGRlbGV0ZSBiZWhhdmlvdXJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRTZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGFydCAtIHRhYkNoYXJhY3Rlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYXBwbHlFZGl0cyh7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0YWIgY2hhcmFjdGVyIGF0IGNhcmV0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQgLSB0YWJDaGFyYWN0ZXIubGVuZ3RoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiB1cGRhdGVkU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBzZWxlY3Rpb25zXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lcyh2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGluZSA9PT0gbnVsbCB8fCBsaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5lLm1hdGNoKC9eXFxzKy8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpbmRlbnRhdGlvbiBvbiBpbnNlcnRpbmcgYSBuZXcgbGluZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZW50ID0gJ1xcbicgKyBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZFNlbGVjdGlvbiA9IHNlbGVjdGlvblN0YXJ0ICsgaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlFZGl0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW5kZW50YXRpb24gY2hhcmFjdGVyIGF0IGNhcmV0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREVfUEFSRU5TIHx8XG4gICAgICAgICAgICBlLmtleUNvZGUgPT09IEtFWUNPREVfQlJBQ0tFVFMgfHxcbiAgICAgICAgICAgIGUua2V5Q29kZSA9PT0gS0VZQ09ERV9RVU9URSB8fFxuICAgICAgICAgICAgZS5rZXlDb2RlID09PSBLRVlDT0RFX0JBQ0tfUVVPVEUpIHtcbiAgICAgICAgICAgIHZhciBjaGFycyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREVfUEFSRU5TICYmIGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBjaGFycyA9IFsnKCcsICcpJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREVfQlJBQ0tFVFMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IFsneycsICd9J107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IFsnWycsICddJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFX1FVT1RFKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBbJ1wiJywgJ1wiJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IFtcIidcIiwgXCInXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9CQUNLX1FVT1RFICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgY2hhcnMgPSBbJ2AnLCAnYCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGV4dCBpcyBzZWxlY3RlZCwgd3JhcCB0aGVtIGluIHRoZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCAmJiBjaGFycykge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBhcHBseUVkaXRzKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNbMF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJzWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQpLFxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCArIDIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGlzTWFjTGlrZVxuICAgICAgICAgICAgPyAvLyBUcmlnZ2VyIHVuZG8gd2l0aCDijJgrWiBvbiBNYWNcbiAgICAgICAgICAgICAgICBlLm1ldGFLZXkgJiYgZS5rZXlDb2RlID09PSBLRVlDT0RFX1pcbiAgICAgICAgICAgIDogLy8gVHJpZ2dlciB1bmRvIHdpdGggQ3RybCtaIG9uIG90aGVyIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgIGUuY3RybEtleSAmJiBlLmtleUNvZGUgPT09IEtFWUNPREVfWikgJiZcbiAgICAgICAgICAgICFlLnNoaWZ0S2V5ICYmXG4gICAgICAgICAgICAhZS5hbHRLZXkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHVuZG9FZGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGlzTWFjTGlrZVxuICAgICAgICAgICAgPyAvLyBUcmlnZ2VyIHJlZG8gd2l0aCDijJgrU2hpZnQrWiBvbiBNYWNcbiAgICAgICAgICAgICAgICBlLm1ldGFLZXkgJiYgZS5rZXlDb2RlID09PSBLRVlDT0RFX1ogJiYgZS5zaGlmdEtleVxuICAgICAgICAgICAgOiBpc1dpbmRvd3NcbiAgICAgICAgICAgICAgICA/IC8vIFRyaWdnZXIgcmVkbyB3aXRoIEN0cmwrWSBvbiBXaW5kb3dzXG4gICAgICAgICAgICAgICAgICAgIGUuY3RybEtleSAmJiBlLmtleUNvZGUgPT09IEtFWUNPREVfWVxuICAgICAgICAgICAgICAgIDogLy8gVHJpZ2dlciByZWRvIHdpdGggQ3RybCtTaGlmdCtaIG9uIG90aGVyIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgICAgICBlLmN0cmxLZXkgJiYgZS5rZXlDb2RlID09PSBLRVlDT0RFX1ogJiYgZS5zaGlmdEtleSkgJiZcbiAgICAgICAgICAgICFlLmFsdEtleSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVkb0VkaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREVfTSAmJlxuICAgICAgICAgICAgZS5jdHJsS2V5ICYmXG4gICAgICAgICAgICAoaXNNYWNMaWtlID8gZS5zaGlmdEtleSA6IHRydWUpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBUb2dnbGUgY2FwdHVyaW5nIHRhYiBrZXkgc28gdXNlcnMgY2FuIGZvY3VzIGF3YXlcbiAgICAgICAgICAgIHNldENhcHR1cmUoZnVuY3Rpb24gKHByZXYpIHsgcmV0dXJuICFwcmV2OyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYSA9IGUuY3VycmVudFRhcmdldCwgdmFsdWUgPSBfYS52YWx1ZSwgc2VsZWN0aW9uU3RhcnQgPSBfYS5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kID0gX2Euc2VsZWN0aW9uRW5kO1xuICAgICAgICByZWNvcmRDaGFuZ2Uoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiBzZWxlY3Rpb25FbmQsXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBvblZhbHVlQ2hhbmdlKHZhbHVlKTtcbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlY29yZEN1cnJlbnRTdGF0ZSgpO1xuICAgIH0sIFtyZWNvcmRDdXJyZW50U3RhdGVdKTtcbiAgICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0IHNlc3Npb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeTogaGlzdG9yeVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IHNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IHNlc3Npb24uaGlzdG9yeTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcmVzdCwgeyBzdHlsZTogX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlcy5jb250YWluZXIpLCBzdHlsZSkgfSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IHByZUNsYXNzTmFtZSwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgc3R5bGU6IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZXMuZWRpdG9yKSwgc3R5bGVzLmhpZ2hsaWdodCksIGNvbnRlbnRTdHlsZSkgfSwgKHR5cGVvZiBoaWdobGlnaHRlZCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8geyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGhpZ2hsaWdodGVkICsgJzxiciAvPicgfSB9XG4gICAgICAgICAgICA6IHsgY2hpbGRyZW46IGhpZ2hsaWdodGVkIH0pKSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiLCB7IHJlZjogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIChpbnB1dFJlZi5jdXJyZW50ID0gYyk7IH0sIHN0eWxlOiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGVzLmVkaXRvciksIHN0eWxlcy50ZXh0YXJlYSksIGNvbnRlbnRTdHlsZSksIGNsYXNzTmFtZTogY2xhc3NOYW1lICsgKHRleHRhcmVhQ2xhc3NOYW1lID8gXCIgXCIuY29uY2F0KHRleHRhcmVhQ2xhc3NOYW1lKSA6ICcnKSwgaWQ6IHRleHRhcmVhSWQsIHZhbHVlOiB2YWx1ZSwgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSwgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLCBvbkNsaWNrOiBvbkNsaWNrLCBvbktleVVwOiBvbktleVVwLCBvbkZvY3VzOiBvbkZvY3VzLCBvbkJsdXI6IG9uQmx1ciwgZGlzYWJsZWQ6IGRpc2FibGVkLCBmb3JtOiBmb3JtLCBtYXhMZW5ndGg6IG1heExlbmd0aCwgbWluTGVuZ3RoOiBtaW5MZW5ndGgsIG5hbWU6IG5hbWUsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgcmVhZE9ubHk6IHJlYWRPbmx5LCByZXF1aXJlZDogcmVxdWlyZWQsIGF1dG9Gb2N1czogYXV0b0ZvY3VzLCBhdXRvQ2FwaXRhbGl6ZTogXCJvZmZcIiwgYXV0b0NvbXBsZXRlOiBcIm9mZlwiLCBhdXRvQ29ycmVjdDogXCJvZmZcIiwgc3BlbGxDaGVjazogZmFsc2UsIFwiZGF0YS1ncmFtbVwiOiBmYWxzZSB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBjc3NUZXh0IH0gfSkpKTtcbn0pO1xudmFyIHN0eWxlcyA9IHtcbiAgICBjb250YWluZXI6IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIH0sXG4gICAgdGV4dGFyZWE6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIHJlc2l6ZTogJ25vbmUnLFxuICAgICAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIE1vek9zeEZvbnRTbW9vdGhpbmc6ICdncmF5c2NhbGUnLFxuICAgICAgICBXZWJraXRGb250U21vb3RoaW5nOiAnYW50aWFsaWFzZWQnLFxuICAgICAgICBXZWJraXRUZXh0RmlsbENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIH0sXG4gICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgfSxcbiAgICBlZGl0b3I6IHtcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgYm94U2l6aW5nOiAnaW5oZXJpdCcsXG4gICAgICAgIGRpc3BsYXk6ICdpbmhlcml0JyxcbiAgICAgICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBmb250U3R5bGU6ICdpbmhlcml0JyxcbiAgICAgICAgZm9udFZhcmlhbnRMaWdhdHVyZXM6ICdpbmhlcml0JyxcbiAgICAgICAgZm9udFdlaWdodDogJ2luaGVyaXQnLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nOiAnaW5oZXJpdCcsXG4gICAgICAgIGxpbmVIZWlnaHQ6ICdpbmhlcml0JyxcbiAgICAgICAgdGFiU2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICB0ZXh0SW5kZW50OiAnaW5oZXJpdCcsXG4gICAgICAgIHRleHRSZW5kZXJpbmc6ICdpbmhlcml0JyxcbiAgICAgICAgdGV4dFRyYW5zZm9ybTogJ2luaGVyaXQnLFxuICAgICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuICAgICAgICB3b3JkQnJlYWs6ICdrZWVwLWFsbCcsXG4gICAgICAgIG92ZXJmbG93V3JhcDogJ2JyZWFrLXdvcmQnLFxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gRWRpdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fY3JlYXRlQmluZGluZyIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJleHBvcnRzIiwiUmVhY3QiLCJyZXF1aXJlIiwiS0VZQ09ERV9ZIiwiS0VZQ09ERV9aIiwiS0VZQ09ERV9NIiwiS0VZQ09ERV9QQVJFTlMiLCJLRVlDT0RFX0JSQUNLRVRTIiwiS0VZQ09ERV9RVU9URSIsIktFWUNPREVfQkFDS19RVU9URSIsIkhJU1RPUllfTElNSVQiLCJISVNUT1JZX1RJTUVfR0FQIiwiaXNXaW5kb3dzIiwid2luZG93IiwidGVzdCIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiaXNNYWNMaWtlIiwiY2xhc3NOYW1lIiwiY3NzVGV4dCIsImNvbmNhdCIsIkVkaXRvciIsImZvcndhcmRSZWYiLCJwcm9wcyIsInJlZiIsImF1dG9Gb2N1cyIsImRpc2FibGVkIiwiZm9ybSIsImhpZ2hsaWdodCIsIl9hIiwiaWdub3JlVGFiS2V5IiwiX2IiLCJpbnNlcnRTcGFjZXMiLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJuYW1lIiwib25CbHVyIiwib25DbGljayIsIm9uRm9jdXMiLCJvbktleURvd24iLCJvbktleVVwIiwib25WYWx1ZUNoYW5nZSIsIl9jIiwicGFkZGluZyIsInBsYWNlaG9sZGVyIiwicHJlQ2xhc3NOYW1lIiwicmVhZE9ubHkiLCJyZXF1aXJlZCIsInN0eWxlIiwiX2QiLCJ0YWJTaXplIiwidGV4dGFyZWFDbGFzc05hbWUiLCJ0ZXh0YXJlYUlkIiwicmVzdCIsImhpc3RvcnlSZWYiLCJ1c2VSZWYiLCJzdGFjayIsIm9mZnNldCIsImlucHV0UmVmIiwiX2UiLCJ1c2VTdGF0ZSIsImNhcHR1cmUiLCJzZXRDYXB0dXJlIiwiY29udGVudFN0eWxlIiwicGFkZGluZ1RvcCIsInRvcCIsInBhZGRpbmdSaWdodCIsInJpZ2h0IiwicGFkZGluZ0JvdHRvbSIsImJvdHRvbSIsInBhZGRpbmdMZWZ0IiwibGVmdCIsImhpZ2hsaWdodGVkIiwiZ2V0TGluZXMiLCJ0ZXh0IiwicG9zaXRpb24iLCJzdWJzdHJpbmciLCJzcGxpdCIsInJlY29yZENoYW5nZSIsInVzZUNhbGxiYWNrIiwicmVjb3JkIiwib3ZlcndyaXRlIiwiY3VycmVudCIsInNsaWNlIiwiY291bnQiLCJleHRyYXMiLCJNYXRoIiwibWF4IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImxhc3QiLCJyZSIsInByZXZpb3VzIiwic2VsZWN0aW9uU3RhcnQiLCJwb3AiLCJtYXRjaCIsInN0YXJ0c1dpdGgiLCJwdXNoIiwicmVjb3JkQ3VycmVudFN0YXRlIiwiaW5wdXQiLCJzZWxlY3Rpb25FbmQiLCJ1cGRhdGVJbnB1dCIsImFwcGx5RWRpdHMiLCJ1bmRvRWRpdCIsInJlZG9FZGl0IiwibWluIiwiaGFuZGxlS2V5RG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJrZXkiLCJjdXJyZW50VGFyZ2V0IiwiYmx1ciIsInRhYkNoYXJhY3RlciIsInJlcGVhdCIsInByZXZlbnREZWZhdWx0Iiwic2hpZnRLZXkiLCJsaW5lc0JlZm9yZUNhcmV0Iiwic3RhcnRMaW5lXzEiLCJlbmRMaW5lXzEiLCJuZXh0VmFsdWUiLCJtYXAiLCJsaW5lIiwiam9pbiIsInN0YXJ0TGluZVRleHQiLCJzdGFydExpbmVfMiIsImVuZExpbmVfMiIsInVwZGF0ZWRTZWxlY3Rpb24iLCJoYXNTZWxlY3Rpb24iLCJ0ZXh0QmVmb3JlQ2FyZXQiLCJlbmRzV2l0aCIsIm1hdGNoZXMiLCJpbmRlbnQiLCJrZXlDb2RlIiwiY2hhcnMiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsdEtleSIsInByZXYiLCJoYW5kbGVDaGFuZ2UiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwic2Vzc2lvbiIsImhpc3RvcnkiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGVzIiwiY29udGFpbmVyIiwiZWRpdG9yIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJjaGlsZHJlbiIsImMiLCJ0ZXh0YXJlYSIsImlkIiwib25DaGFuZ2UiLCJhdXRvQ2FwaXRhbGl6ZSIsImF1dG9Db21wbGV0ZSIsImF1dG9Db3JyZWN0Iiwic3BlbGxDaGVjayIsInRleHRBbGlnbiIsImJveFNpemluZyIsIm92ZXJmbG93IiwiaGVpZ2h0Iiwid2lkdGgiLCJyZXNpemUiLCJjb2xvciIsIk1vek9zeEZvbnRTbW9vdGhpbmciLCJXZWJraXRGb250U21vb3RoaW5nIiwiV2Via2l0VGV4dEZpbGxDb2xvciIsInBvaW50ZXJFdmVudHMiLCJtYXJnaW4iLCJib3JkZXIiLCJiYWNrZ3JvdW5kIiwiZGlzcGxheSIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnRTdHlsZSIsImZvbnRWYXJpYW50TGlnYXR1cmVzIiwiZm9udFdlaWdodCIsImxldHRlclNwYWNpbmciLCJsaW5lSGVpZ2h0IiwidGV4dEluZGVudCIsInRleHRSZW5kZXJpbmciLCJ0ZXh0VHJhbnNmb3JtIiwid2hpdGVTcGFjZSIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-simple-code-editor/lib/index.js\n");

/***/ })

};
;